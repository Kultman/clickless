namespace GabeSoft.Common

open System
open System.Collections.Generic

exception UndefinedException
exception EmptyStreamException

/// An infinite lazy list.
[<NoEquality; NoComparison>]
type 'a Stream =
   { mutable Status : 'a StreamCellStatus }

   member x.Value =
      match x.Status with
      | Value a   -> a
      | _         -> 
         lock x (fun () -> 
            match x.Status with
            | Delayed d -> x.Status <- Error UndefinedException
                           try 
                              let v = d.Force()
                              x.Status <- Value v
                              v
                           with e -> 
                              x.Status <- Error e
                              reraise()
            | Value a   -> a
            | Error e   -> raise e)

   member x.GetEnumeratorImpl () =
      let getCell (x : 'a Stream) = x.Value
      let toSeq s = 
         Seq.unfold (fun lst ->
            match getCell lst with
            | StreamNil          -> None
            | StreamCons (a, t)  -> Some (a, t)) s
      (toSeq x).GetEnumerator()

   interface IEnumerable<'a> with
      member x.GetEnumerator() = x.GetEnumeratorImpl()

   interface System.Collections.IEnumerable with
      override x.GetEnumerator() = (x.GetEnumeratorImpl() :> System.Collections.IEnumerator)

and 
   [<NoEquality; NoComparison>]
   'a StreamCellStatus =
   | Delayed of Lazy<'a StreamCell>
   | Value of 'a StreamCell
   | Error of System.Exception

and 
   [<NoEquality; NoComparison>]
   'a StreamCell = 
   | StreamNil 
   | StreamCons of 'a * 'a Stream

[<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]
module Stream =
   let private argEx msg = new ArgumentException(msg)
   let private knfEx msg = new KeyNotFoundException (msg)
   
   let private delay d = { Status = Delayed d }
   let private force (x : 'a Stream) = x.Value

   let rec (|Cons|Nil|) (s : 'a Stream) =
      match force s with
      | StreamNil          -> Nil
      | StreamCons (a, t)  -> Cons (a, t)

   /// Returns an empty stream of the specified type.
   let empty<'a> = { Status = Value (StreamNil : 'a StreamCell) }

   let private nil = StreamNil
   let private consc h t = StreamCons (h, t)
   
   /// Returns a stream with head as its first element and tail
   /// as its subsequent elements. 
   let cons head tail = delay (lazy (consc head tail))

   /// Returns a stream that is passed in as a lazy value.
   /// The value is not executed until the first element of the stream 
   /// is consumed.
   let delayed (s : Lazy<'a Stream>) = delay (lazy (force (s.Force())))
   
   /// Returns a stream with head as its first element and tail
   /// as its subsequent elements. Tail is expected to be a lazy value.
   let consl head (tail : Lazy<'a Stream>) = cons head (delayed tail)
   
   /// Returns a stream composed only of the given element.
   let unit x = cons x empty<_>

   /// Returns the first element of the stream.
   let head = function
   | Nil          -> raise EmptyStreamException
   | Cons (a, t)  -> a

   /// Returns the stream corresponding to the remaining elements
   /// after the first one has been removed.
   let tail = function
   | Nil          -> raise EmptyStreamException
   | Cons (a, t)  -> t 
   
   /// Returns true if the specified stream is empty.
   let isEmpty = function 
   | Nil    -> true
   | _      -> false      

   /// Computes the length of the given stream. 
   /// This will force the evaluation of the entire stream.
   let length s =
      let rec aux n s = 
         match s with
         | Nil          -> n
         | Cons (_, t)  -> aux (n + 1) t
      aux 0 s

   /// Returns a streams that contains the elements returned by the given computation.
   /// The given computation is not executed until the first element in the stream is
   /// consumed.  The given argument is passed to the computation.  Subsequent elements
   /// in the list are generated by again applying the residual 'b to the computation.
   let rec unfold f b =
      delay (lazy 
         (match f b with
         | None            -> nil
         | Some (a, rest)  -> consc a (unfold f rest)))
   
   /// Returns a new stream that contains the elements of the first
   /// stream followed by the elements of the second stream.    
   let rec append s1 s2 = delay (lazy (appendc s1 s2))
   and private appendc s1 s2 =
      match s1 with
      | Nil          -> force s2
      | Cons (a, t)  -> consc a (append t s2)

   /// Appends a value to the end of a stream. 
   /// Only recommended for small streams.
   let snoc x s = append s (unit x)   

   /// Appends a value to the end of a stream.
   /// The value is expected to be wrapped in a lazy expression.
   let snocl (x : Lazy<'a>) s = append s (delay (lazy (consc (x.Force()) empty<_>)))

   /// Converts the given stream to a list.
   let toList s =
      let rec loop s acc = 
         match s with
         | Nil          -> List.rev acc
         | Cons (a, t)  -> loop t (a::acc)
      loop s []

   /// Converts the given list to a stream.
   let rec ofList s =
      delay (lazy 
         (match s with
         | []     -> nil
         | h::t   -> consc h (ofList t)))

   /// Converts the given stream to a sequence.   
   let toSeq (s : 'a Stream) = s :> IEnumerable<_>
   
   /// Converts the given sequence to a stream.
   let ofSeq (c : IEnumerable<_>) =
      let rec enumerator (e : IEnumerator<_>) =
         delay (lazy 
            (  if e.MoveNext () 
               then consc e.Current (enumerator e)
               else e.Dispose()
                    nil))
      enumerator (c.GetEnumerator())

   /// Converts the given array to a stream.
   let ofArray a =
      let rec copy n a =
         delay (lazy 
            (  if n >= Array.length a 
               then nil 
               else consc a.[n] (copy (n + 1) a)))
      copy 0 a

   /// Converts the given stream to an array.
   let toArray (s : 'a Stream) = 
      let n = length s
      let a = Array.create<_> n Unchecked.defaultof<'a>
      let mutable i = 0
      for e in s do
         a.[i] <- e
         i <- i + 1
      a

   /// Builds a new stream whose elements are the result of
   /// applying the given function to each of the stream elements.
   let rec map f s = 
      delay (lazy 
         (match s with
         | Nil          -> nil
         | Cons (a, t)  -> consc (f a) (map f t)))

   /// Returns the first n elements of the stream.
   let rec take n s =
      if n <= 0 then empty<_> else
      delay (lazy
         (match s with
         | Nil          -> nil
         | Cons (a, t)  -> consc a (take (n - 1) t)))

   /// Returns the largest prefix of the given stream for
   /// which the specified predicate holds.
   let rec takeWhile f s =
      delay (lazy 
         (match s with
         | Nil          -> nil
         | Cons (a, t)  -> if f a 
                           then consc a (takeWhile f t)
                           else nil))

   /// Returns a stream with the first n elements removed.
   let rec skip n s = 
      if n <= 0 then s else
      delay (lazy
         (match s with
         | Nil          -> nil
         | Cons (a, t)  -> force (skip (n - 1) t))) 

   /// Returns the stream remaining after the first elements
   /// that match the specified predicate have been removed.                     
   let rec skipWhile f s = 
      delay (lazy
         (match s with
         | Nil          -> nil
         | Cons (a, t)  -> if f a
                           then force (skipWhile f t)
                           else force s))

   /// Returns a constant stream where all elements are equal to 
   /// the specified value.
   let rec repeat a = delay (lazy consc a (repeat a))  

   /// Returns the nth element of a stream (indexed at 0).
   let rec nth n s =
      if n < 0 then raise (argEx "invalid index")
      match s with
      | Cons (a, t) when n = 0   -> a
      | Cons (_, t)              -> nth (n - 1) t
      | Nil                      -> raise (argEx "insufficient items in stream")

   /// Applies the given function to each element of the stream.
   let rec iter f = function
      | Nil          -> ()
      | Cons (a, t)  -> f a; iter f t

   /// Removes any elements from the given stream that do not
   /// satisfy the specified predicate.      
   let rec filter f s = delay (lazy filterc f s)
   and private filterc f = function
   | Nil          -> nil
   | Cons (a, t)  -> if f a 
                     then consc a (filter f t)
                     else filterc f t

   /// Creates an alternating stream of elements from the specified 
   /// element and the stream elements.
   let intersperse x s = 
      let rec loop x yes s = delay (lazy (loopc x yes s))
      and loopc x yes s = 
         match s with
         | Nil          -> nil
         | Cons (a, t)  -> if yes 
                           then consc x (loop x false s)
                           else consc a (loop x true t)
      loop x true s

   /// Interleaves two streams alternating elements from each one.
   let interleave s1 s2 =
      let rec loop first s1 s2 = delay (lazy (loopc first s1 s2))
      and loopc first s1 s2 =
         match s1, s2 with
         | Nil, Nil                       -> nil
         | Nil, Cons (_, _)               -> force s2
         | Cons (_, _), Nil               -> force s1
         | Cons (a1, t1), Cons (a2, t2)   -> 
            if first
            then consc a1 (loop false t1 s2)
            else consc a2 (loop true s1 t2)
      loop true s1 s2

   /// Return a new list consisting of the results of applying the given accumulating function
   /// to successive elements of the list.
   let rec scan f acc s =
      delay (lazy 
         (match s with
         | Nil          -> consc acc empty<_>
         | Cons (a, t)  -> let next = f acc a
                           consc acc (scan f next t)))
      
   /// Left fold.
   let rec foldl f acc = function
      | Nil          -> acc
      | Cons (a, t)  -> foldl f (f acc a) t

   /// Right fold.
   let foldr f acc s = 
      (foldl (fun g x -> (fun y -> g (f x y))) id s) acc

   /// Returns the infinite repetition of the specified list.
   let rec cycle xs = delay (lazy appendc (ofList xs) (cycle xs))

   /// Computes the transposition of a stream of streams.
   /// [[1,2,3],[4,5,6]] -> [[1,4],[2,5],[3,6]]
   let rec transpose s =
      delay (lazy 
         (match s with
         | Nil                         -> nil
         | Cons (a, _) when isEmpty a  -> nil
         | Cons (_, _)  -> consc (map head s) (transpose (map tail s))))

   /// Apply the given function to successive elements of the list, returning the first
   /// result where function returns <c>Some(x)</c> for some x. If the function never returns
   /// true, 'None' is returned.
   let rec tryFind f s =
      match s with
      | Nil    -> None
      | Cons (a, t)  -> if f a then Some a else tryFind f t

   /// Return the first element for which the given function returns <c>true</c>.
   /// Raise <c>KeyNotFoundException</c> if no such element exists.
   let find f s =
      match tryFind f s with
      | Some a -> a
      | None   -> raise (knfEx "An index satisfying the given predicate was not found in the collection.")

   /// Takes two streams and returns the stream created 
   /// by combining the elements two by two according to the given function.
   let rec zipWith f s1 s2 = 
      delay (lazy
         (match s1, s2 with
         | Nil, Nil                       -> nil
         | Cons (a1, t1), Cons (a2, t2)   -> consc (f a1 a2) (zipWith f t1 t2)
         | _                              -> raise (argEx "equal streams expected")))

   /// Takes two streams and returns the stream of 
   /// corresponding pairs.
   let zip s1 s2 = zipWith (fun a b -> a, b) s1 s2

   /// Return the stream which contains on demand the 
   /// stream of elements of the given stream of streams.
   let rec concat s = 
      delay (lazy 
         (match s with
         | Nil          -> nil
         | Cons (a, t)  -> appendc a (concat t)))

   /// Applies the given function to each element of
   /// the specified stream and concatenates the results.
   let rec collect f s = concat (map f s)

   /// Reverses the specified stream.
   let rec reverse s = 
      let rec rev = function
      | Nil, r          -> force r
      | Cons (a, t), r  -> rev (t, cons a r)
      delay (lazy (rev (s, empty<_>)))

   /// Converts a stream to its string representation.
   let toString s = 
      let n = 6
      let small = take (n + 1) s
      let items = map (fun e -> sprintf "%A" e) (take n small) |> String.concat "; "
      match length small with
      | l when l > n -> sprintf "stream [%s; ...]" items
      | _            -> sprintf "stream [%s]" items   

type 'a Stream with
   override x.ToString() = Stream.toString x

type StreamBuilder () =
   member x.Bind (m, f) = Stream.collect f m
   member x.Return a = Stream.unit a
   member x.ReturnFrom s = s
   member x.Yield a = Stream.unit a
   member x.YieldFrom m = m
   member x.Delay s = s ()
   member x.For (m, f) = Stream.collect f (Stream.ofSeq m)
   member x.Zero () = Stream.empty<_>
   member x.Combine (m1, m2) = Stream.append m1 m2